# 奶狗快跑 - 匹配算法设计文档

## 1. 算法整体架构

### 1.1 多阶段匹配流程
```
用户画像生成 → 候选召回 → 特征匹配打分 → 重排序 → 个性化推荐
```

### 1.2 召回策略（Multi-Stage Retrieval）

#### Stage 1: 基础过滤（倒排索引）
- **地域匹配**：优先同城，其次相邻城市（50km内）
- **年龄区间**：严格匹配目标区间（18-25 或 28-38）
- **身份验证**：仅选择已通过认证的用户
- **状态过滤**：排除已拉黑、已删除、高风险用户

#### Stage 2: 向量召回（ANN检索）
- **兴趣向量**：基于用户兴趣标签生成的128维向量
- **需求向量**：基于社交需求生成的64维向量
- **价值观向量**：基于价值观倾向生成的64维向量
- **使用 Faiss/Milvus**：快速检索Top-K相似用户（K=100-200）

#### Stage 3: 活跃度加权
- **最近活跃**：7天内活跃用户优先
- **新用户冷启动**：新注册用户（7天内）给予曝光优先
- **会员优先级**：会员用户排序提升

## 2. 匹配打分算法

### 2.1 综合匹配分数计算

```python
# 伪代码
def calculate_match_score(user_a, user_b):
    """
    计算用户A和用户B的匹配分数（0-100分）
    """
    scores = {}
    
    # 1. 兴趣重合度（权重40%）
    interest_score = calculate_interest_overlap(
        user_a.interests, 
        user_b.interests
    )
    scores['interest'] = interest_score * 0.4
    
    # 2. 社交需求契合度（权重30%）
    needs_score = calculate_needs_compatibility(
        user_a.social_needs,
        user_b.social_needs
    )
    scores['needs'] = needs_score * 0.3
    
    # 3. 价值观相似度（权重20%）
    values_score = calculate_values_similarity(
        user_a.values,
        user_b.values
    )
    scores['values'] = values_score * 0.2
    
    # 4. AI外貌匹配度（权重10%）
    appearance_score = calculate_appearance_match(
        user_a.ai_scores,
        user_b.ai_scores,
        user_a.appearance_pref,
        user_b.appearance_pref
    )
    scores['appearance'] = appearance_score * 0.1
    
    # 5. 基础匹配度（加分项）
    base_bonus = calculate_base_bonus(user_a, user_b)
    
    # 总分计算
    total_score = sum(scores.values()) + base_bonus
    
    # 匹配原因生成
    match_reasons = generate_match_reasons(scores, user_a, user_b)
    
    return {
        'total_score': min(100, max(0, total_score)),
        'detail_scores': scores,
        'match_reasons': match_reasons
    }
```

### 2.2 各维度详细计算

#### 2.2.1 兴趣重合度计算
```python
def calculate_interest_overlap(interests_a, interests_b):
    """
    计算兴趣重合度
    方法：Jaccard相似度 + 兴趣排序权重
    """
    set_a = set(interests_a)
    set_b = set(interests_b)
    
    # Jaccard相似度
    intersection = len(set_a & set_b)
    union = len(set_a | set_b)
    jaccard = intersection / union if union > 0 else 0
    
    # 排序权重（前3个兴趣权重更高）
    weight_sum = 0
    for i, interest in enumerate(interests_a[:3]):
        if interest in interests_b:
            weight = 3 - i  # 第一个兴趣权重3，第二个2，第三个1
            weight_sum += weight
    
    max_weight = 6  # 3+2+1
    weight_score = weight_sum / max_weight if max_weight > 0 else 0
    
    # 综合分数（Jaccard 70% + 权重 30%）
    score = jaccard * 0.7 + weight_score * 0.3
    
    return score * 100  # 转换为0-100分
```

#### 2.2.2 社交需求契合度计算
```python
def calculate_needs_compatibility(needs_a, needs_b):
    """
    计算社交需求契合度
    方法：需求交集 + 需求互补性
    """
    set_a = set(needs_a)
    set_b = set(needs_b)
    
    # 直接匹配度
    intersection = len(set_a & set_b)
    union = len(set_a | set_b)
    direct_match = intersection / union if union > 0 else 0
    
    # 需求互补性（如A需要陪伴，B愿意陪伴）
    complement_map = {
        '陪伴聊天': ['陪伴聊天', '线下活动'],
        '线下活动': ['线下活动', '兴趣组队'],
        '职业交流': ['职业交流', '资源对接'],
        '兴趣组队': ['兴趣组队', '线下活动']
    }
    
    complement_score = 0
    for need_a in needs_a:
        if need_a in complement_map:
            compatible_needs = complement_map[need_a]
            if any(need in needs_b for need in compatible_needs):
                complement_score += 1
    
    max_complement = len(needs_a)
    complement_ratio = complement_score / max_complement if max_complement > 0 else 0
    
    # 综合分数（直接匹配60% + 互补40%）
    score = direct_match * 0.6 + complement_ratio * 0.4
    
    return score * 100
```

#### 2.2.3 价值观相似度计算
```python
def calculate_values_similarity(values_a, values_b):
    """
    计算价值观相似度
    方法：向量余弦相似度
    """
    # 价值观维度映射
    value_dimensions = {
        'consumption': ['理性消费', '适度消费', '享受消费'],
        'boundary': ['严格边界', '适度边界', '开放边界'],
        'communication': ['直接沟通', '委婉沟通', '灵活沟通']
    }
    
    # 构建向量
    vec_a = []
    vec_b = []
    
    for dim, options in value_dimensions.items():
        val_a = values_a.get(dim, '')
        val_b = values_b.get(dim, '')
        
        # 计算该维度的相似度
        if val_a == val_b:
            similarity = 1.0
        elif val_a in options and val_b in options:
            idx_a = options.index(val_a)
            idx_b = options.index(val_b)
            # 距离越近，相似度越高
            distance = abs(idx_a - idx_b)
            max_distance = len(options) - 1
            similarity = 1.0 - (distance / max_distance) if max_distance > 0 else 0
        else:
            similarity = 0.5  # 默认中等相似度
        
        vec_a.append(similarity)
        vec_b.append(similarity)
    
    # 余弦相似度
    dot_product = sum(a * b for a, b in zip(vec_a, vec_b))
    norm_a = sum(a * a for a in vec_a) ** 0.5
    norm_b = sum(b * b for b in vec_b) ** 0.5
    
    cosine_sim = dot_product / (norm_a * norm_b) if (norm_a * norm_b) > 0 else 0
    
    return cosine_sim * 100
```

#### 2.2.4 AI外貌匹配度计算
```python
def calculate_appearance_match(scores_a, scores_b, pref_a, pref_b):
    """
    计算AI外貌匹配度
    方法：气质/风格/协调度综合 + 偏好匹配
    """
    # AI评分维度
    ai_dimensions = ['气质匹配度', '风格契合度', '整体协调度']
    
    # 计算双方AI评分的匹配度
    match_scores = []
    for dim in ai_dimensions:
        score_a = scores_a.get(dim, 5.0)  # 默认5分
        score_b = scores_b.get(dim, 5.0)
        
        # 分数越接近，匹配度越高
        diff = abs(score_a - score_b)
        match_score = 1.0 - (diff / 10.0)  # 最大差异10分
        match_scores.append(max(0, match_score))
    
    ai_match = sum(match_scores) / len(match_scores)
    
    # 偏好匹配度
    style_a = pref_a.get('style', '')
    style_b = pref_b.get('style', '')
    acceptance_a = pref_a.get('acceptance', '')
    acceptance_b = pref_b.get('acceptance', '')
    
    pref_match = 0.5  # 默认中等匹配
    if style_a and style_b:
        if style_a == style_b:
            pref_match = 1.0
        else:
            # 风格兼容性矩阵
            compatible_styles = {
                '休闲': ['休闲', '运动'],
                '正式': ['正式', '商务'],
                '运动': ['运动', '休闲']
            }
            if style_b in compatible_styles.get(style_a, []):
                pref_match = 0.8
    
    # 综合分数（AI匹配70% + 偏好30%）
    score = ai_match * 0.7 + pref_match * 0.3
    
    return score * 100
```

#### 2.2.5 基础匹配加分项
```python
def calculate_base_bonus(user_a, user_b):
    """
    计算基础匹配加分项
    """
    bonus = 0
    
    # 同城加分
    if user_a.city == user_b.city:
        bonus += 5
    
    # 作息匹配加分
    if user_a.schedule == user_b.schedule:
        bonus += 3
    
    # 资产证明加分（仅对女生）
    if user_b.role == 'female' and user_b.asset_flag:
        bonus += 2
    
    # 会员加分
    if user_a.member_level != 'normal':
        bonus += 2
    if user_b.member_level != 'normal':
        bonus += 2
    
    return min(10, bonus)  # 最高加10分
```

## 3. 重排序策略

### 3.1 多样性保证
```python
def rerank_candidates(candidates, user_id):
    """
    重排序候选列表，保证多样性
    """
    # 1. 按匹配分数排序
    candidates.sort(key=lambda x: x['match_score'], reverse=True)
    
    # 2. 多样性惩罚（避免推荐同质化用户）
    reranked = []
    seen_tags = set()
    
    for candidate in candidates:
        # 计算多样性得分
        candidate_tags = set(candidate.get('tags', []))
        overlap = len(candidate_tags & seen_tags)
        diversity_penalty = overlap * 0.1  # 每个重叠标签扣0.1分
        
        # 应用惩罚
        final_score = candidate['match_score'] - diversity_penalty
        
        reranked.append({
            **candidate,
            'final_score': final_score
        })
        
        seen_tags.update(candidate_tags)
    
    # 3. 按最终分数重新排序
    reranked.sort(key=lambda x: x['final_score'], reverse=True)
    
    return reranked[:10]  # 返回Top-10
```

### 3.2 冷启动处理
```python
def handle_cold_start(user):
    """
    新用户冷启动策略
    """
    if user.register_days < 7:  # 注册7天内
        # 提高曝光优先级
        priority_multiplier = 1.5
        
        # 降低匹配分数门槛
        min_score_threshold = 60  # 正常是70
    else:
        priority_multiplier = 1.0
        min_score_threshold = 70
    
    return {
        'priority_multiplier': priority_multiplier,
        'min_score_threshold': min_score_threshold
    }
```

## 4. 实时更新与反馈优化

### 4.1 用户行为反馈
```python
def update_match_weights(user_id, action_history):
    """
    根据用户行为反馈更新匹配权重
    """
    # 统计用户喜欢/不喜欢的用户特征
    liked_features = []
    disliked_features = []
    
    for action in action_history:
        if action['type'] == 'like':
            liked_features.append(action['target_features'])
        elif action['type'] == 'pass':
            disliked_features.append(action['target_features'])
            # 分析拒绝原因
            reason = action.get('reason', '')
            if '兴趣不符' in reason:
                # 降低兴趣权重
                adjust_weight('interest', -0.05)
            elif '价值观不合' in reason:
                # 提高价值观权重
                adjust_weight('values', +0.05)
    
    # 使用机器学习模型更新权重（长期优化）
    # 这里简化处理，实际应使用A/B测试和模型训练
```

### 4.2 匹配结果追踪
```python
def track_match_result(match_id, user_a, user_b):
    """
    追踪匹配结果，用于算法优化
    """
    metrics = {
        'match_score': calculate_match_score(user_a, user_b),
        'chat_initiated': False,  # 是否发起聊天
        'messages_count': 0,  # 消息数量
        'contact_unlocked': False,  # 是否解锁联系方式
        'match_duration': 0,  # 匹配持续时间
        'user_satisfaction': None  # 用户满意度（从反馈获取）
    }
    
    # 记录到数据库，用于后续分析
    save_match_metrics(match_id, metrics)
```

## 5. 性能优化

### 5.1 离线预计算
- **画像向量化**：用户画像向量在注册/更新时计算并存储
- **候选集缓存**：热门用户的候选列表缓存1小时
- **匹配分数缓存**：用户对之间的匹配分数缓存24小时

### 5.2 在线优化
- **批量计算**：使用SIMD指令加速向量计算
- **异步处理**：非关键路径（如AI评分）异步计算
- **限流保护**：单个用户匹配请求限流（每分钟最多10次）

## 6. A/B测试框架

```python
def get_match_strategy(user_id):
    """
    根据A/B测试分组返回匹配策略
    """
    group = get_ab_group(user_id, 'match_algorithm')
    
    if group == 'A':
        # 策略A：兴趣权重40%，需求30%，价值观20%，外貌10%
        weights = {'interest': 0.4, 'needs': 0.3, 'values': 0.2, 'appearance': 0.1}
    elif group == 'B':
        # 策略B：兴趣权重35%，需求35%，价值观20%，外貌10%
        weights = {'interest': 0.35, 'needs': 0.35, 'values': 0.2, 'appearance': 0.1}
    else:
        weights = get_default_weights()
    
    return weights
```

## 7. 监控指标

- **匹配成功率**：匹配后48小时内发起聊天的比例
- **匹配质量**：匹配后解锁联系方式的比例
- **用户满意度**：匹配评分平均值
- **算法性能**：匹配请求响应时间（P50/P95/P99）
